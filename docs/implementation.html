<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Implementation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Symbolic_computation_ica1</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction</span></div></a></li><li class="depth-1  current"><a href="implementation.html"><div class="inner"><span>Implementation</span></div></a></li><li class="depth-1 "><a href="future.html"><div class="inner"><span>Future Improvements</span></div></a></li><li class="depth-1 "><a href="ica2.html"><div class="inner"><span>ICA2</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>symbolic-computation-ica1</span></div></div></li><li class="depth-2 branch"><a href="symbolic-computation-ica1.chatbot.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>chatbot</span></div></a></li><li class="depth-2 branch"><a href="symbolic-computation-ica1.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="symbolic-computation-ica1.dog_identifying.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dog_identifying</span></div></a></li><li class="depth-2 branch"><a href="symbolic-computation-ica1.formatting.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>formatting</span></div></a></li><li class="depth-2 branch"><a href="symbolic-computation-ica1.matching.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>matching</span></div></a></li><li class="depth-2"><a href="symbolic-computation-ica1.scraper.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scraper</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#implementation" id="implementation"></a>Implementation</h1>
<p>The program parses user input as a string, first sanitising the input to remove unnecessary characters such as punctuation marks:</p>
<pre><code>(str/lower-case)
(str/replace #"[;,.!?\\]" "")
(park-to-keyword)))
</code></pre>
<p>The input then gets split into a vector with one word as an element and gets matched against chosen keywords. From <code>matching/match</code>:</p>
<pre><code>matched-park (match-keywords park-names input false)
matched-info (match-keywords synonyms input true)
matched-park-info (get (get parks matched-park) matched-info)
</code></pre>
<p>Based on the information that was matched (or wasn’t), a bot response in generated:</p>
<ul>
<li>If only park is matched, bot prints general information about the park and the available keywords for that park:</li>
</ul>
<pre><code>(not (nil? park))
  (print-bot (format "%s\n\nI can tell you about %s in %s."
               (get (get hist-data park) :description)
               (matching/get-parks-activities park)
               (formatting/keyword-to-park park)))
</code></pre>
<ul>
<li>If only a keyword is matched, bot responds with a list of parks that contain information for that keyword:</li>
</ul>
<pre><code>(not (nil? info))
  (print-bot (format "I have information about %s in %s."
               (name info)
               (formatting/format-park-names (matching/get-parks-with-keyword info))))
</code></pre>
<ul>
<li>
<p>If both the keyword and the park is matched, bot tries to get information from the <code>parks</code> map.</p>
</li>
<li>
<p>If selected park contains the identified keyword, bot responds, providing user with an answer to their question:</p>
</li>
</ul>
<pre><code>(and (not (nil? park)) (not (nil? info)) (not (nil? park-info)))
  (print-bot (formatting/translate-values-found
              park (name info) park-info))
</code></pre>
<ul>
<li>If selected park doesn’t contain the keyword, a bot performs a search of the parks that do, giving user an option to query other parks:</li>
</ul>
<pre><code>(and (not (nil? park)) (not (nil? info)))
  (print-bot (format "%s %s"
              (formatting/translate-values-not-found (name info))
              (formatting/format-park-names (matching/get-parks-with-keyword info)))
</code></pre>
<ul>
<li>There’s an additional <code>else</code> case with a response to all unmatched results:</li>
</ul>
<pre><code>:else
  (print-bot "Sorry, I'm not sure what you mean"))
</code></pre>
<h2><a href="#notable-design-decisions" id="notable-design-decisions"></a>Notable design decisions</h2>
<p>The goal of this implementation was to create a feeling of a real conversation instead of simply a “query program”. Therefore, the program contains several key features:</p>
<ul>
<li>The users don’t need to select a specific park or a specific activity. Instead, they can write questions like <code>Where can I bike?</code> or <code>I want to know more about Vysehrad</code> and receive an appropriate response:</li>
</ul>
<pre><code>Anastasia&gt; Where can I bike?
Bot&gt; I have information about biking in Bertramka, Vysehrad, Kinskeho zahrada, Petrin, Riegrovy sady, Obora hvezda, Kampa, Frantiskanska zahrada, Ladronka, Letenske sady, Stromovka, Klamovka.
Anastasia&gt; I want to know more about Vysehrad
Bot&gt; Next to the entrance to the Podolská hospital, a narrow steep path winds, which perhaps does not even have a name. It waves between old houses, and whoever reaches the end of it finds himself in front of a tunnel leading through the hill and the fortifications.

I can tell you about wc, attractions, biking, skating, sports, playground, transportation, parking in Vysehrad.
</code></pre>
<ul>
<li>Bot remembers the park user talked about in the previous message and users don’t have to specify the park they’re talking about every time - it’s assumed. Following the previous example:</li>
</ul>
<pre><code>...
I can tell you about wc, attractions, biking, skating, sports, playground, transportation, parking in Vysehrad.
Anastasia&gt; Can I bike there?
Bot&gt; Yes, you can bike in Vysehrad!
</code></pre>
<ul>
<li>Bot can recommend user a place to visit:</li>
</ul>
<pre><code>Anastasia&gt; What kind of sights can I see in this park?
Bot&gt; Available attractions in Vysehrad are: sightseeing, museum, cemetery of famous personalities Slavín, national cultural monument.
How about visiting the cemetery of famous personalities Slavín? Sounds interesting!
</code></pre>
<p>In addition, it’s worth noting that the use of <code>some</code> and <code>map</code> in <code>matching</code> functions is intentional. <code>matching/match-keyword-with-syn</code> uses <code>some</code> because, for every keyword it attempts to match, it should only return one keyword, even if (accidentally) it ended up with two matches. However, for the <code>matching/match-keywords</code> function <code>map</code> provides an opportunity to locate several keywords in one user input. Right now, only the first match is used, but the logic makes it possible to match several keywords in the future.</p>
</div></div></div></body></html>